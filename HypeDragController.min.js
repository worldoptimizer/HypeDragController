/*
 Hype Drag Controller v1.4.0
 Copyright (2024) Max Ziebell, MIT License
*/
'use strict';"HypeDragController"in window===!1&&(window.HypeDragController=function(){function p(a){return a?q[a]:q}function m(a){a=a.documentId();t[a]||(t[a]={dragData:{},interactionMap:{},constraints:{}});return t[a]}function A(a,b){const c=b.getElementById(b.currentSceneId()).querySelectorAll("[data-drop-target]"),d=b.getElementProperty(a,"left"),e=b.getElementProperty(a,"top"),f=b.getElementProperty(a,"width"),h=b.getElementProperty(a,"height");let g=null,k=0;for(let u=0;u<c.length;u++){const n=
c[u];if(n===a)continue;var l=b.getElementProperty(n,"left");const r=b.getElementProperty(n,"top"),v=b.getElementProperty(n,"width"),w=b.getElementProperty(n,"height");d<l+v&&d+f>l&&e<r+w&&e+h>r&&(l=Math.max(0,Math.min(d+f,l+v)-Math.max(d,l))*Math.max(0,Math.min(e+h,r+w)-Math.max(e,r)),l>k&&(k=l,g=n))}return g}function B(a,b,c){if(b==="parent"){var d=a.parentElement;if(!d)return console.warn("HypeDragController: Element has no parent for containment constraint.",a),{minX:-Infinity,maxX:Infinity,minY:-Infinity,
maxY:Infinity}}else if(typeof b==="string"){if(d=c.getElementById(c.currentSceneId()).querySelector(b),!d)return console.warn('HypeDragController: Containment selector "'+b+'" not found.',a),{minX:-Infinity,maxX:Infinity,minY:-Infinity,maxY:Infinity}}else if(b&&b.id)d=b;else return console.warn("HypeDragController: Invalid containment specification.",a),{minX:-Infinity,maxX:Infinity,minY:-Infinity,maxY:Infinity};b=c.getElementProperty(d,"left");const e=c.getElementProperty(d,"top"),f=c.getElementProperty(d,
"width");d=c.getElementProperty(d,"height");const h=c.getElementProperty(a,"width");a=c.getElementProperty(a,"height");return{minX:b,maxX:b+f-h,minY:e,maxY:e+d-a}}function C(a,b,c){const d=m(a),e=b.dataset.dragName;if(e){var f=p();if(c.hypeGesturePhase==="start"){if(b.hasAttribute("data-initial-left")){var h=parseFloat(b.getAttribute("data-initial-left"));var g=parseFloat(b.getAttribute("data-initial-top"))}else h=a.getElementProperty(b,"left"),g=a.getElementProperty(b,"top"),b.setAttribute("data-initial-left",
h),b.setAttribute("data-initial-top",g);d.dragData[e]={initialLeft:h,initialTop:g,initialZ:a.getElementProperty(b,"z-index"),startX:c.hypeGestureXPosition,startY:c.hypeGestureYPosition,isActive:!0};f.bringToFront&&a.setElementProperty(b,"z-index",9999);if((f=d.interactionMap?.[e])&&typeof f.onStart==="function")f.onStart(a,b,c)}if(c.hypeGesturePhase==="move"&&d.dragData[e]){g=d.dragData[e];f=g.initialLeft+(c.hypeGestureXPosition-g.startX);h=g.initialTop+(c.hypeGestureYPosition-g.startY);const k=d.constraints?.[e];
k&&(k.minX!==void 0&&(f=Math.max(f,k.minX)),k.maxX!==void 0&&(f=Math.min(f,k.maxX)),k.minY!==void 0&&(h=Math.max(h,k.minY)),k.maxY!==void 0&&(h=Math.min(h,k.maxY)),k.axis==="x"&&(h=g.initialTop),k.axis==="y"&&(f=g.initialLeft),k.containment&&(g=B(b,k.containment,a),f=Math.max(g.minX,Math.min(f,g.maxX)),h=Math.max(g.minY,Math.min(h,g.maxY))));a.setElementProperty(b,"left",f);a.setElementProperty(b,"top",h);if((f=d.interactionMap?.[e])&&typeof f.onProgress==="function")f.onProgress(a,b,c)}if((c.hypeGesturePhase===
"end"||c.hypeGesturePhase==="cancel")&&d.dragData[e]&&d.dragData[e].isActive){d.dragData[e].isActive=!1;f=A(b,a);c.dropTarget=f;if((f=d.interactionMap?.[e])&&typeof f.onDrop==="function")f.onDrop(a,b,c);setTimeout(()=>{delete d.dragData[e]},50)}}else console.warn('HypeDragController: Draggable element is missing a "data-drag-name" attribute.',b)}function D(a,b){var c=m(a),d=b.dataset.dragName;d&&(c=c.dragData[d])&&(d=p(),a.setElementProperty(b,"left",c.initialLeft,d.snapBackDuration,d.snapBackTiming),
a.setElementProperty(b,"top",c.initialTop,d.snapBackDuration,d.snapBackTiming),d.bringToFront&&a.setElementProperty(b,"z-index",c.initialZ,d.snapBackDuration,"easeinout"))}function E(a,b,c){if(b&&c){if(typeof c==="string"){var d=a.getElementById(a.currentSceneId()).querySelector(c);if(!d)return console.warn('HypeDragController: snapTo selector "'+c+'" did not find an element.')}else if(typeof c==="object"&&c.id)d=c;else return console.warn("HypeDragController: snapTo destination must be an element or selector string.");
c=p();var e=a.getElementProperty(d,"left");d=a.getElementProperty(d,"top");a.setElementProperty(b,"left",e,c.snapToDuration,c.snapToTiming);a.setElementProperty(b,"top",d,c.snapToDuration,c.snapToTiming)}}function F(a,b){b.classList.add("hypeDragElementLocked")}function x(a,b){b.classList.remove("hypeDragElementLocked")}function G(a,b){m(a).interactionMap=b}function H(a,b,c){const d=m(a);Array.isArray(b)?b.forEach(e=>{y(a,d,e,c)}):y(a,d,b,c)}function y(a,b,c,d){if(typeof c==="string")a=c;else if(a=
c.dataset.dragName,!a){console.warn('HypeDragController: Cannot set constraints on element without "data-drag-name" attribute.',c);return}b.constraints[a]=d||{}}function I(a){const b=m(a);a.getElementById(a.currentSceneId()).querySelectorAll("[data-drag-name]").forEach(c=>{const d=c.dataset.dragName,e={};c.hasAttribute("data-constraint-min-x")&&(e.minX=parseFloat(c.getAttribute("data-constraint-min-x")));c.hasAttribute("data-constraint-max-x")&&(e.maxX=parseFloat(c.getAttribute("data-constraint-max-x")));
c.hasAttribute("data-constraint-min-y")&&(e.minY=parseFloat(c.getAttribute("data-constraint-min-y")));c.hasAttribute("data-constraint-max-y")&&(e.maxY=parseFloat(c.getAttribute("data-constraint-max-y")));c.hasAttribute("data-constraint-axis")&&(e.axis=c.getAttribute("data-constraint-axis"));c.hasAttribute("data-constraint-containment")&&(e.containment=c.getAttribute("data-constraint-containment"));Object.keys(e).length>0&&(b.constraints[d]=e)})}function z(a,b){b||=a.getElementById(a.currentSceneId());
b.querySelectorAll("[data-drag-name]").forEach(c=>{x(a,c);c.removeAttribute("data-initial-left");c.removeAttribute("data-initial-top")});m(a).interactionMap={};a.customData&&(a.customData.gameState={})}let q={bringToFront:!0,snapBackDuration:.4,snapBackTiming:"easeinout",snapToDuration:.3,snapToTiming:"easeout",resetOnSceneUnload:!1};const t={};"HYPE_eventListeners"in window===!1&&(window.HYPE_eventListeners=[]);window.HYPE_eventListeners.push({type:"HypeDocumentLoad",callback:function(a,b,c){document.getElementById("HypeDragControllerStyles")||
(b=document.createElement("style"),b.id="HypeDragControllerStyles",b.innerHTML=".hypeDragElementLocked, .hypeDragElementLocked * { pointer-events: none !important; }",document.head.appendChild(b));a.drag={handler:C.bind(null,a),snapBack:D.bind(null,a),snapTo:E.bind(null,a),lock:F.bind(null,a),unlock:x.bind(null,a),setInteractionMap:G.bind(null,a),setConstraints:H.bind(null,a),resetState:z.bind(null,a)};a.customData.gameState={}}});window.HYPE_eventListeners.push({type:"HypeScenePrepareForDisplay",
callback:function(a,b,c){I(a)}});window.HYPE_eventListeners.push({type:"HypeSceneUnload",callback:function(a,b,c){p("resetOnSceneUnload")&&z(a,b)}});return{version:"1.4.0",setDefault:function(a,b){typeof a==="object"?q=Object.assign(q,a):q[a]=b},getDefault:p}}());
