/*
 Hype Drag Controller v1.2.1
 Copyright (2024) Max Ziebell, MIT License

 A self-contained, physics-agnostic drag-and-drop controller for Tumult Hype.
 Provides a namespaced API, data-attribute-based target detection, and a direct-invocation
 interaction map for clean, centralized scene logic.
*/
'use strict';!1==="HypeDragController"in window&&(window.HypeDragController=function(){function n(a){return a?m[a]:m}function p(a){a=a.documentId();r[a]||(r[a]={dragData:{},interactionMap:{}});return r[a]}function x(a,b){const c=b.getElementById(b.currentSceneId()).querySelectorAll("[data-drop-target]"),d=b.getElementProperty(a,"left"),e=b.getElementProperty(a,"top"),f=b.getElementProperty(a,"width"),g=b.getElementProperty(a,"height");let h=null,u=0;for(let t=0;t<c.length;t++){const l=c[t];if(l===
a)continue;var k=b.getElementProperty(l,"left");const q=b.getElementProperty(l,"top"),v=b.getElementProperty(l,"width"),w=b.getElementProperty(l,"height");d<k+v&&d+f>k&&e<q+w&&e+g>q&&(k=Math.max(0,Math.min(d+f,k+v)-Math.max(d,k))*Math.max(0,Math.min(e+g,q+w)-Math.max(e,q)),k>u&&(u=k,h=l))}return h}function y(a,b,c){const d=p(a),e=b.dataset.dragName;if(e){var f=n();if("start"===c.hypeGesturePhase){let h;if(b.hasAttribute("data-initial-left")){var g=parseFloat(b.getAttribute("data-initial-left"));h=
parseFloat(b.getAttribute("data-initial-top"))}else g=a.getElementProperty(b,"left"),h=a.getElementProperty(b,"top"),b.setAttribute("data-initial-left",g),b.setAttribute("data-initial-top",h);d.dragData[e]={initialLeft:g,initialTop:h,initialZ:a.getElementProperty(b,"z-index"),startX:c.hypeGestureXPosition,startY:c.hypeGestureYPosition,isActive:!0};f.bringToFront&&a.setElementProperty(b,"z-index",9999);if((f=d.interactionMap?.[e])&&"function"===typeof f.onStart)f.onStart(a,b,c)}if("move"===c.hypeGesturePhase&&
d.dragData[e]&&(f=d.dragData[e],g=f.initialTop+(c.hypeGestureYPosition-f.startY),a.setElementProperty(b,"left",f.initialLeft+(c.hypeGestureXPosition-f.startX)),a.setElementProperty(b,"top",g),(f=d.interactionMap?.[e])&&"function"===typeof f.onProgress))f.onProgress(a,b,c);if(("end"===c.hypeGesturePhase||"cancel"===c.hypeGesturePhase)&&d.dragData[e]&&d.dragData[e].isActive){d.dragData[e].isActive=!1;c=x(b,a);if((f=d.interactionMap?.[e])&&"function"===typeof f.onDrop)f.onDrop(a,b,c);setTimeout(()=>
{delete d.dragData[e]},50)}}else console.warn('HypeDragController: Draggable element is missing a "data-drag-name" attribute.',b)}function z(a,b){var c=p(a),d=b.dataset.dragName;d&&(c=c.dragData[d])&&(d=n(),a.setElementProperty(b,"left",c.initialLeft,d.snapBackDuration,d.snapBackTiming),a.setElementProperty(b,"top",c.initialTop,d.snapBackDuration,d.snapBackTiming),d.bringToFront&&a.setElementProperty(b,"z-index",c.initialZ,d.snapBackDuration,"easeinout"))}function A(a,b,c){if(b&&c){if("string"===
typeof c){var d=a.getElementById(a.currentSceneId()).querySelector(c);if(!d)return console.warn('HypeDragController: snapTo selector "'+c+'" did not find an element.')}else if("object"===typeof c&&c.id)d=c;else return console.warn("HypeDragController: snapTo destination must be an element or selector string.");c=n();var e=a.getElementProperty(d,"left");d=a.getElementProperty(d,"top");a.setElementProperty(b,"left",e,c.snapToDuration,c.snapToTiming);a.setElementProperty(b,"top",d,c.snapToDuration,c.snapToTiming)}}
function B(a,b){b.classList.add("hypeDragElementLocked")}function C(a,b){b.classList.remove("hypeDragElementLocked")}function D(a,b){p(a).interactionMap=b}let m={bringToFront:!0,snapBackDuration:.4,snapBackTiming:"easeinout",snapToDuration:.3,snapToTiming:"easeout"};const r={};!1==="HYPE_eventListeners"in window&&(window.HYPE_eventListeners=[]);window.HYPE_eventListeners.push({type:"HypeDocumentLoad",callback:function(a,b,c){document.getElementById("HypeDragControllerStyles")||(b=document.createElement("style"),
b.id="HypeDragControllerStyles",b.innerHTML=".hypeDragElementLocked, .hypeDragElementLocked * { pointer-events: none !important; }",document.head.appendChild(b));a.drag={handler:y.bind(null,a),snapBack:z.bind(null,a),snapTo:A.bind(null,a),lock:B.bind(null,a),unlock:C.bind(null,a),setInteractionMap:D.bind(null,a)};a.customData.gameState={}}});window.HYPE_eventListeners.push({type:"HypeSceneUnload",callback:function(a,b,c){p(a).interactionMap={};a.customData&&(a.customData.gameState={})}});return{version:"1.2.1",
setDefault:function(a,b){"object"===typeof a?m=Object.assign(m,a):m[a]=b},getDefault:n}}());
